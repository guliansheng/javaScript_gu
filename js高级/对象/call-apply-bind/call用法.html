<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>

</body>
<script type="text/javascript">
    // Function.prototype.call=function(context){
    //     1、让this这个函数中的"this关键字"变为context
    //     2、让this方法在执行:
    //        this()
    // }
    var json = {
        name:'json',
        age:45
    }
    function fn1(){console.log(1)}
    function fn2(){console.log(2)}
    fn1.call(fn2);//首先fn1通过原型链机制找到Function.prototype上的call方法,并且让call方法执行,此时call方法中的this就是我要操作的fn1,在call方法代码执行的过程中首先让fn1中的"this关键字"变为fn2,然后再让fn1这个方法执行 => 1

    fn1.call.call(fn2);//首先fn1通过原型链找到Function.prototypeti的cal1方法，然后再让cal1方法通过原型再找到Function原型上的call（因为call本身的值也是一个函数，所以同样可以找到Function.prototype），在第二次在找到call的时候让方法执行，方法中的this是fn1.call，首先让这个方法中的this变为fn2，然后再让fn1.call执行 => 2

    fn1.call.call.call.call.call(fn2) // => 2

    Function.prototype.call(fn1) // => 让Function.prototype这个空函数执行,没有意义

    Function.prototype.call.call.call(fn1) // => 让fn1执行  => 1

    console.log(Array.prototype.sort.call(json,function(a,b){a-b}))
</script>
</html>